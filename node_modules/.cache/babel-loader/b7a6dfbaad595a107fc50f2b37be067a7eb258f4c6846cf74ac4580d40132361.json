{"ast":null,"code":"import { TileType } from './state';\nconst COLORS = {\n  RED: '#ff0000',\n  GREEN: '#00ff00',\n  BLUE: '#0000ff'\n}; // const toDoubleHexa = (n: number) =>\n//   n < 16 ? '0' + n.toString(16) : n.toString(16)\n// export const rgbaTorgb = (rgb: string, alpha = 0) => {\n//   let r = 0\n//   let g = 0\n//   let b = 0\n//   if (rgb.startsWith('#')) {\n//     const hexR = rgb.length === 7 ? rgb.slice(1, 3) : rgb[1]\n//     const hexG = rgb.length === 7 ? rgb.slice(3, 5) : rgb[2]\n//     const hexB = rgb.length === 7 ? rgb.slice(5, 7) : rgb[3]\n//     r = parseInt(hexR, 16)\n//     g = parseInt(hexG, 16)\n//     b = parseInt(hexB, 16)\n//   }\n//   if (rgb.startsWith('rgb')) {\n//     const val = rgb.replace(/(rgb)|\\(|\\)| /g, '')\n//     const splitted = val.split(',')\n//     r = parseInt(splitted[0])\n//     g = parseInt(splitted[1])\n//     b = parseInt(splitted[2])\n//   }\n//   r = Math.max(Math.min(Math.floor((1 - alpha) * r + alpha * 255), 255), 0)\n//   g = Math.max(Math.min(Math.floor((1 - alpha) * g + alpha * 255), 255), 0)\n//   b = Math.max(Math.min(Math.floor((1 - alpha) * b + alpha * 255), 255), 0)\n//   return `#${toDoubleHexa(r)}${toDoubleHexa(g)}${toDoubleHexa(b)}`\n// }\n// const clear = (ctx: CanvasRenderingContext2D) => {\n//   const { height, width } = ctx.canvas\n//   ctx.fillStyle = 'white'\n//   ctx.fillRect(0, 0, width, height)\n// }\n// const drawCirle = (\n//   ctx: CanvasRenderingContext2D,\n//   { x, y }: { x: number; y: number },\n//   color: string\n// ) => {\n//   ctx.beginPath()\n//   ctx.fillStyle = color\n//   ctx.arc(x, y, conf.RADIUS, 0, 2 * Math.PI)\n//   ctx.fill()\n// }\n// const computeColor = (life: number, maxLife: number, baseColor: string) =>\n//   rgbaTorgb(baseColor, (maxLife - life) * (1 / maxLife))\n\nexport const render = ctx => state => {\n  const tileSize = 40;\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  for (let y = 0; y < state.gameMap.height; y++) {\n    for (let x = 0; x < state.gameMap.width; x++) {\n      const tile = state.gameMap.tiles[y][x];\n\n      switch (tile) {\n        case TileType.WALL:\n          ctx.fillStyle = 'black';\n          break;\n\n        case TileType.BREAKABLE:\n          ctx.fillStyle = 'brown';\n          break;\n\n        case TileType.WATER:\n          ctx.fillStyle = 'blue';\n          break;\n\n        case TileType.EMPTY:\n          ctx.fillStyle = 'white';\n          break;\n\n        case TileType.EXPLOSION:\n          ctx.fillStyle = 'red';\n          break;\n      }\n\n      ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);\n    }\n  }\n};","map":{"version":3,"sources":["/home/munou/stl/year_2/2/cpa/projet_de_0/canvas-master/src/components/canvas/renderer.ts"],"names":["TileType","COLORS","RED","GREEN","BLUE","render","ctx","state","tileSize","clearRect","canvas","width","height","y","gameMap","x","tile","tiles","WALL","fillStyle","BREAKABLE","WATER","EMPTY","EXPLOSION","fillRect"],"mappings":"AACA,SAASA,QAAT,QAAgC,SAAhC;AACA,MAAMC,MAAM,GAAG;AACbC,EAAAA,GAAG,EAAE,SADQ;AAEbC,EAAAA,KAAK,EAAE,SAFM;AAGbC,EAAAA,IAAI,EAAE;AAHO,CAAf,C,CAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA,OAAO,MAAMC,MAAM,GAAIC,GAAD,IAAoCC,KAAD,IAAkB;AACzE,QAAMC,QAAQ,GAAG,EAAjB;AACAF,EAAAA,GAAG,CAACG,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoBH,GAAG,CAACI,MAAJ,CAAWC,KAA/B,EAAsCL,GAAG,CAACI,MAAJ,CAAWE,MAAjD;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,KAAK,CAACO,OAAN,CAAcF,MAAlC,EAA0CC,CAAC,EAA3C,EAA+C;AAC7C,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,KAAK,CAACO,OAAN,CAAcH,KAAlC,EAAyCI,CAAC,EAA1C,EAA8C;AAC5C,YAAMC,IAAI,GAAGT,KAAK,CAACO,OAAN,CAAcG,KAAd,CAAoBJ,CAApB,EAAuBE,CAAvB,CAAb;;AAEA,cAAQC,IAAR;AACE,aAAKhB,QAAQ,CAACkB,IAAd;AACEZ,UAAAA,GAAG,CAACa,SAAJ,GAAgB,OAAhB;AACA;;AACF,aAAKnB,QAAQ,CAACoB,SAAd;AACEd,UAAAA,GAAG,CAACa,SAAJ,GAAgB,OAAhB;AACA;;AACF,aAAKnB,QAAQ,CAACqB,KAAd;AACEf,UAAAA,GAAG,CAACa,SAAJ,GAAgB,MAAhB;AACA;;AACF,aAAKnB,QAAQ,CAACsB,KAAd;AACEhB,UAAAA,GAAG,CAACa,SAAJ,GAAgB,OAAhB;AACA;;AACF,aAAKnB,QAAQ,CAACuB,SAAd;AACEjB,UAAAA,GAAG,CAACa,SAAJ,GAAgB,KAAhB;AACA;AAfJ;;AAiBAb,MAAAA,GAAG,CAACkB,QAAJ,CAAaT,CAAC,GAAGP,QAAjB,EAA2BK,CAAC,GAAGL,QAA/B,EAAyCA,QAAzC,EAAmDA,QAAnD;AACD;AACF;AACF,CA3BM","sourcesContent":["import * as conf from './conf'\nimport { TileType, State } from './state'\nconst COLORS = {\n  RED: '#ff0000',\n  GREEN: '#00ff00',\n  BLUE: '#0000ff',\n}\n\n// const toDoubleHexa = (n: number) =>\n//   n < 16 ? '0' + n.toString(16) : n.toString(16)\n\n// export const rgbaTorgb = (rgb: string, alpha = 0) => {\n//   let r = 0\n//   let g = 0\n//   let b = 0\n//   if (rgb.startsWith('#')) {\n//     const hexR = rgb.length === 7 ? rgb.slice(1, 3) : rgb[1]\n//     const hexG = rgb.length === 7 ? rgb.slice(3, 5) : rgb[2]\n//     const hexB = rgb.length === 7 ? rgb.slice(5, 7) : rgb[3]\n//     r = parseInt(hexR, 16)\n//     g = parseInt(hexG, 16)\n//     b = parseInt(hexB, 16)\n//   }\n//   if (rgb.startsWith('rgb')) {\n//     const val = rgb.replace(/(rgb)|\\(|\\)| /g, '')\n//     const splitted = val.split(',')\n//     r = parseInt(splitted[0])\n//     g = parseInt(splitted[1])\n//     b = parseInt(splitted[2])\n//   }\n\n//   r = Math.max(Math.min(Math.floor((1 - alpha) * r + alpha * 255), 255), 0)\n//   g = Math.max(Math.min(Math.floor((1 - alpha) * g + alpha * 255), 255), 0)\n//   b = Math.max(Math.min(Math.floor((1 - alpha) * b + alpha * 255), 255), 0)\n//   return `#${toDoubleHexa(r)}${toDoubleHexa(g)}${toDoubleHexa(b)}`\n// }\n\n// const clear = (ctx: CanvasRenderingContext2D) => {\n//   const { height, width } = ctx.canvas\n//   ctx.fillStyle = 'white'\n//   ctx.fillRect(0, 0, width, height)\n// }\n\n// const drawCirle = (\n//   ctx: CanvasRenderingContext2D,\n//   { x, y }: { x: number; y: number },\n//   color: string\n// ) => {\n//   ctx.beginPath()\n//   ctx.fillStyle = color\n//   ctx.arc(x, y, conf.RADIUS, 0, 2 * Math.PI)\n//   ctx.fill()\n// }\n\n// const computeColor = (life: number, maxLife: number, baseColor: string) =>\n//   rgbaTorgb(baseColor, (maxLife - life) * (1 / maxLife))\n\nexport const render = (ctx: CanvasRenderingContext2D) => (state: State) => {\n  const tileSize = 40\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n  for (let y = 0; y < state.gameMap.height; y++) {\n    for (let x = 0; x < state.gameMap.width; x++) {\n      const tile = state.gameMap.tiles[y][x]\n\n      switch (tile) {\n        case TileType.WALL:\n          ctx.fillStyle = 'black'\n          break\n        case TileType.BREAKABLE:\n          ctx.fillStyle = 'brown'\n          break\n        case TileType.WATER:\n          ctx.fillStyle = 'blue'\n          break\n        case TileType.EMPTY:\n          ctx.fillStyle = 'white'\n          break\n        case TileType.EXPLOSION:\n          ctx.fillStyle = 'red'\n          break\n      }\n      ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize)\n    }\n  }\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}