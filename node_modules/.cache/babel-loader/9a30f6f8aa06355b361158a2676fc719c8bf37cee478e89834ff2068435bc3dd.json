{"ast":null,"code":"export let TileType;\n\n(function (TileType) {\n  TileType[TileType[\"EMPTY\"] = 0] = \"EMPTY\";\n  TileType[TileType[\"WALL\"] = 1] = \"WALL\";\n  TileType[TileType[\"BREAKABLE\"] = 2] = \"BREAKABLE\";\n  TileType[TileType[\"EXPLOSION\"] = 3] = \"EXPLOSION\";\n  TileType[TileType[\"WATER\"] = 4] = \"WATER\";\n})(TileType || (TileType = {}));\n\nexport const generateMap = (width, height) => {\n  const map = [];\n\n  for (let y = 0; y < height; y++) {\n    const row = [];\n\n    for (let x = 0; x < width; x++) {\n      if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {\n        row.push(TileType.WALL);\n      } else if (x % 2 === 0 && y % 2 === 0) {\n        row.push(TileType.WALL);\n      } else {\n        const random = Math.random();\n\n        if (random < 0.2) {\n          row.push(TileType.BREAKABLE);\n        } else if (random < 0.25) {\n          row.push(TileType.WATER);\n        } else {\n          row.push(TileType.EMPTY);\n        }\n      }\n    }\n\n    map.push(row);\n  }\n\n  map[1][1] = TileType.EMPTY;\n  map[1][2] = TileType.EMPTY;\n  map[2][1] = TileType.EMPTY;\n  return map;\n}; // type Coord = { x: number; y: number; dx: number; dy: number }\n// type Ball = { coord: Coord; life: number; invincible?: number }\n// type Size = { height: number; width: number }\n// export type State = {\n//   pos: Array<Ball>\n//   size: Size\n//   endOfGame: boolean\n// }\n// const dist2 = (o1: Coord, o2: Coord) =>\n//   Math.pow(o1.x - o2.x, 2) + Math.pow(o1.y - o2.y, 2)\n// const iterate = (bound: Size) => (ball: Ball) => {\n//   const invincible = ball.invincible ? ball.invincible - 1 : ball.invincible\n//   const coord = ball.coord\n//   const dx =\n//     (coord.x + conf.RADIUS > bound.width || coord.x < conf.RADIUS\n//       ? -coord.dx\n//       : coord.dx) * conf.FRICTION\n//   const dy =\n//     (coord.y + conf.RADIUS > bound.height || coord.y < conf.RADIUS\n//       ? -coord.dy\n//       : coord.dy) * conf.FRICTION\n//   if (Math.abs(dx) + Math.abs(dy) < conf.MINMOVE)\n//     return { ...ball, invincible, coord: { ...coord, dx: 0, dy: 0 } }\n//   return {\n//     ...ball,\n//     invincible,\n//     coord: {\n//       x: coord.x + dx,\n//       y: coord.y + dy,\n//       dx,\n//       dy,\n//     },\n//   }\n// }\n// export const click =\n//   (state: State) =>\n//   (event: PointerEvent): State => {\n//     const { offsetX, offsetY } = event\n//     const target = state.pos.find(\n//       (p) =>\n//         dist2(p.coord, { x: offsetX, y: offsetY, dx: 0, dy: 0 }) <\n//         Math.pow(conf.RADIUS, 2) + 100\n//     )\n//     if (target) {\n//       target.coord.dx += Math.random() * 10\n//       target.coord.dy += Math.random() * 10\n//     }\n//     return state\n//   }\n// const collide = (o1: Coord, o2: Coord) =>\n//   dist2(o1, o2) < Math.pow(2 * conf.RADIUS, 2)\n// const collideBoing = (p1: Coord, p2: Coord) => {\n//   const nx = (p2.x - p1.x) / (2 * conf.RADIUS)\n//   const ny = (p2.y - p1.y) / (2 * conf.RADIUS)\n//   const gx = -ny\n//   const gy = nx\n//   const v1g = gx * p1.dx + gy * p1.dy\n//   const v2n = nx * p2.dx + ny * p2.dy\n//   const v2g = gx * p2.dx + gy * p2.dy\n//   const v1n = nx * p1.dx + ny * p1.dy\n//   p1.dx = nx * v2n + gx * v1g\n//   p1.dy = ny * v2n + gy * v1g\n//   p2.dx = nx * v1n + gx * v2g\n//   p2.dy = ny * v1n + gy * v2g\n//   p1.x += p1.dx\n//   p1.y += p1.dy\n//   p2.x += p2.dx\n//   p2.y += p2.dy\n// }\n// export const step = (state: State) => {\n//   state.pos.map((p1, i, arr) => {\n//     arr.slice(i + 1).map((p2) => {\n//       if (collide(p1.coord, p2.coord)) {\n//         if (!p1.invincible) {\n//           p1.life--\n//           p1.invincible = 20\n//         }\n//         if (!p2.invincible) {\n//           p2.life--\n//           p2.invincible = 20\n//         }\n//         collideBoing(p1.coord, p2.coord)\n//       }\n//     })\n//   })\n//   return {\n//     ...state,\n//     pos: state.pos.map(iterate(state.size)).filter((p) => p.life > 0),\n//   }\n// }\n// export const mouseMove =\n//   (state: State) =>\n//   (event: PointerEvent): State => {\n//     return state\n//   }\n// export const endOfGame = (state: State): boolean => true","map":{"version":3,"sources":["/home/munou/stl/year_2/2/cpa/projet_de_0/canvas-master/src/components/canvas/state.ts"],"names":["TileType","generateMap","width","height","map","y","row","x","push","WALL","random","Math","BREAKABLE","WATER","EMPTY"],"mappings":"AAEA,WAAYA,QAAZ;;WAAYA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;AAAAA,EAAAA,Q,CAAAA,Q;GAAAA,Q,KAAAA,Q;;AAqDZ,OAAO,MAAMC,WAAW,GAAG,CAACC,KAAD,EAAgBC,MAAhB,KAAiD;AAC1E,QAAMC,GAAiB,GAAG,EAA1B;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAApB,EAA4BE,CAAC,EAA7B,EAAiC;AAC/B,UAAMC,GAAe,GAAG,EAAxB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAApB,EAA2BK,CAAC,EAA5B,EAAgC;AAC9B,UAAIA,CAAC,KAAK,CAAN,IAAWA,CAAC,KAAKL,KAAK,GAAG,CAAzB,IAA8BG,CAAC,KAAK,CAApC,IAAyCA,CAAC,KAAKF,MAAM,GAAG,CAA5D,EAA+D;AAC7DG,QAAAA,GAAG,CAACE,IAAJ,CAASR,QAAQ,CAACS,IAAlB;AACD,OAFD,MAGK,IAAIF,CAAC,GAAG,CAAJ,KAAU,CAAV,IAAeF,CAAC,GAAG,CAAJ,KAAU,CAA7B,EAAgC;AACnCC,QAAAA,GAAG,CAACE,IAAJ,CAASR,QAAQ,CAACS,IAAlB;AACD,OAFI,MAGD;AACF,cAAMC,MAAM,GAAGC,IAAI,CAACD,MAAL,EAAf;;AACA,YAAIA,MAAM,GAAG,GAAb,EAAkB;AAChBJ,UAAAA,GAAG,CAACE,IAAJ,CAASR,QAAQ,CAACY,SAAlB;AACD,SAFD,MAEO,IAAIF,MAAM,GAAG,IAAb,EAAmB;AACxBJ,UAAAA,GAAG,CAACE,IAAJ,CAASR,QAAQ,CAACa,KAAlB;AACD,SAFM,MAEA;AACLP,UAAAA,GAAG,CAACE,IAAJ,CAASR,QAAQ,CAACc,KAAlB;AACD;AACF;AACF;;AACDV,IAAAA,GAAG,CAACI,IAAJ,CAASF,GAAT;AACD;;AAEDF,EAAAA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,IAAYJ,QAAQ,CAACc,KAArB;AACAV,EAAAA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,IAAYJ,QAAQ,CAACc,KAArB;AACAV,EAAAA,GAAG,CAAC,CAAD,CAAH,CAAO,CAAP,IAAYJ,QAAQ,CAACc,KAArB;AAEA,SAAOV,GAAP;AACD,CA/BM,C,CAgCP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["import * as conf from './conf'\n\nexport enum TileType {\n  EMPTY,\n  WALL,\n  BREAKABLE,\n  EXPLOSION,\n  WATER\n}\n\nexport type Player = {\n  x : number\n  y : number\n  alive : boolean\n  bombs : number\n  bombRange : number\n}\n\nexport type Bomb = {\n  x : number\n  y : number\n  range : number\n  timer : number\n  owner : number\n}\n\nexport type Explosion = {\n  x : number\n  y : number\n  duration : number\n}\n\nexport type Enemy = {\n  x : number\n  y : number\n  alive : boolean\n  direction : 'up' | 'down' | 'left' | 'right'\n}\n\nexport type GameMap = {\n  width: number\n  height: number\n  tiles: TileType[][]\n}\n\nexport type State = {\n  player: Player\n  bombs: Bomb[]\n  explosions: Explosion[]\n  enemies: Enemy[]\n  gameMap: GameMap\n  gameOver: boolean\n  victory: boolean\n}\n\nexport const generateMap = (width: number, height: number): TileType[][] => {\n  const map: TileType[][] = []\n\n  for (let y = 0; y < height; y++) {\n    const row: TileType[] = []\n    for (let x = 0; x < width; x++) {\n      if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {\n        row.push(TileType.WALL)\n      }\n      else if (x % 2 === 0 && y % 2 === 0) {\n        row.push(TileType.WALL)\n      }\n      else{\n        const random = Math.random()\n        if (random < 0.2) {\n          row.push(TileType.BREAKABLE)\n        } else if (random < 0.25) {\n          row.push(TileType.WATER)\n        } else {\n          row.push(TileType.EMPTY)\n        }\n      }\n    }\n    map.push(row)\n  }\n\n  map[1][1] = TileType.EMPTY\n  map[1][2] = TileType.EMPTY\n  map[2][1] = TileType.EMPTY\n\n  return map\n}\n// type Coord = { x: number; y: number; dx: number; dy: number }\n// type Ball = { coord: Coord; life: number; invincible?: number }\n// type Size = { height: number; width: number }\n// export type State = {\n//   pos: Array<Ball>\n//   size: Size\n//   endOfGame: boolean\n// }\n\n// const dist2 = (o1: Coord, o2: Coord) =>\n//   Math.pow(o1.x - o2.x, 2) + Math.pow(o1.y - o2.y, 2)\n\n// const iterate = (bound: Size) => (ball: Ball) => {\n//   const invincible = ball.invincible ? ball.invincible - 1 : ball.invincible\n//   const coord = ball.coord\n//   const dx =\n//     (coord.x + conf.RADIUS > bound.width || coord.x < conf.RADIUS\n//       ? -coord.dx\n//       : coord.dx) * conf.FRICTION\n//   const dy =\n//     (coord.y + conf.RADIUS > bound.height || coord.y < conf.RADIUS\n//       ? -coord.dy\n//       : coord.dy) * conf.FRICTION\n//   if (Math.abs(dx) + Math.abs(dy) < conf.MINMOVE)\n//     return { ...ball, invincible, coord: { ...coord, dx: 0, dy: 0 } }\n//   return {\n//     ...ball,\n//     invincible,\n//     coord: {\n//       x: coord.x + dx,\n//       y: coord.y + dy,\n//       dx,\n//       dy,\n//     },\n//   }\n// }\n\n// export const click =\n//   (state: State) =>\n//   (event: PointerEvent): State => {\n//     const { offsetX, offsetY } = event\n//     const target = state.pos.find(\n//       (p) =>\n//         dist2(p.coord, { x: offsetX, y: offsetY, dx: 0, dy: 0 }) <\n//         Math.pow(conf.RADIUS, 2) + 100\n//     )\n//     if (target) {\n//       target.coord.dx += Math.random() * 10\n//       target.coord.dy += Math.random() * 10\n//     }\n//     return state\n//   }\n\n// const collide = (o1: Coord, o2: Coord) =>\n//   dist2(o1, o2) < Math.pow(2 * conf.RADIUS, 2)\n\n// const collideBoing = (p1: Coord, p2: Coord) => {\n//   const nx = (p2.x - p1.x) / (2 * conf.RADIUS)\n//   const ny = (p2.y - p1.y) / (2 * conf.RADIUS)\n//   const gx = -ny\n//   const gy = nx\n\n//   const v1g = gx * p1.dx + gy * p1.dy\n//   const v2n = nx * p2.dx + ny * p2.dy\n//   const v2g = gx * p2.dx + gy * p2.dy\n//   const v1n = nx * p1.dx + ny * p1.dy\n//   p1.dx = nx * v2n + gx * v1g\n//   p1.dy = ny * v2n + gy * v1g\n//   p2.dx = nx * v1n + gx * v2g\n//   p2.dy = ny * v1n + gy * v2g\n//   p1.x += p1.dx\n//   p1.y += p1.dy\n//   p2.x += p2.dx\n//   p2.y += p2.dy\n// }\n\n// export const step = (state: State) => {\n//   state.pos.map((p1, i, arr) => {\n//     arr.slice(i + 1).map((p2) => {\n//       if (collide(p1.coord, p2.coord)) {\n//         if (!p1.invincible) {\n//           p1.life--\n//           p1.invincible = 20\n//         }\n//         if (!p2.invincible) {\n//           p2.life--\n//           p2.invincible = 20\n//         }\n//         collideBoing(p1.coord, p2.coord)\n//       }\n//     })\n//   })\n//   return {\n//     ...state,\n//     pos: state.pos.map(iterate(state.size)).filter((p) => p.life > 0),\n//   }\n// }\n\n// export const mouseMove =\n//   (state: State) =>\n//   (event: PointerEvent): State => {\n//     return state\n//   }\n\n// export const endOfGame = (state: State): boolean => true\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}