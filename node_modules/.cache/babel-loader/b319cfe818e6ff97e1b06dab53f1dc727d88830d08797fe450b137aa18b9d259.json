{"ast":null,"code":"// Sorbonne Université\n// M1 STL 2024/2025\n// Conception et Pratique de l’Algorithmique\n// Projet final: Refonte d'une application de jeu vidéo\n// ALABDULLAH Muhannad\n// 21317509\n// Ce fichier contient les structures des différents éléments du jeu\n//\n// Il contient également des fonctions pour générer la carte, et l'état initial du jeu\n//\n// et pour gérer les explosions des bombes\nimport * as conf from './conf';\nexport let TileType;\n\n(function (TileType) {\n  TileType[TileType[\"EMPTY\"] = 0] = \"EMPTY\";\n  TileType[TileType[\"WALL\"] = 1] = \"WALL\";\n  TileType[TileType[\"BREAKABLE\"] = 2] = \"BREAKABLE\";\n  TileType[TileType[\"EXPLOSION\"] = 3] = \"EXPLOSION\";\n  TileType[TileType[\"WATER\"] = 4] = \"WATER\";\n})(TileType || (TileType = {}));\n\nexport const generateMap = (width, height) => {\n  const map = [];\n\n  for (let y = 0; y < height; y++) {\n    const row = [];\n\n    for (let x = 0; x < width; x++) {\n      if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {\n        row.push(TileType.WALL);\n      } else if (x % 2 === 0 && y % 2 === 0) {\n        row.push(TileType.WALL);\n      } else {\n        const random = Math.random();\n\n        if (random < conf.BREAKABLEPROBABILITY) {\n          row.push(TileType.BREAKABLE);\n        } else if (random < conf.WATERPROBABILITYAUX) {\n          row.push(TileType.WATER);\n        } else {\n          row.push(TileType.EMPTY);\n        }\n      }\n    }\n\n    map.push(row);\n  } // Afin de rassurer que les case de départ sont vides\n\n\n  map[1][1] = TileType.EMPTY;\n  map[1][2] = TileType.EMPTY;\n  map[2][1] = TileType.EMPTY;\n  return map;\n};\nexport const isWalkable = tile => {\n  return tile === TileType.EMPTY || tile === TileType.WATER;\n};\nexport const explodeBomb = (bomb, state) => {\n  const {\n    x,\n    y,\n    range\n  } = bomb;\n  state.bombs = state.bombs.filter(b => b !== bomb);\n\n  if (bomb.owner === 'player') {\n    state.player.bombs++;\n  }\n\n  const affectTiles = (tx, ty) => {\n    if (tx >= 0 && tx < state.gameMap.width && ty >= 0 && ty < state.gameMap.height) {\n      const tile = state.gameMap.tiles[ty][tx];\n\n      if (tile === TileType.BREAKABLE) {\n        // Casser les briques\n        state.gameMap.tiles[ty][tx] = TileType.EMPTY;\n        state.score += conf.BREAKABLESCORE; // Score pour les briques\n\n        state.floatingTexts.push({\n          // Texte flottant pour le score des briques\n          x: tx * conf.TILESIZE,\n          y: ty * conf.TILESIZE,\n          value: `+${conf.BREAKABLESCORE}`,\n          duration: conf.FLOATTEXTDURATION\n        });\n\n        if (Math.random() < conf.POWERUPROBABILITY) {\n          // Chance de faire apparaître un powerup\n          const types = ['bomb', 'range', 'freeze'];\n          const type = types[Math.floor(Math.random() * types.length)];\n          state.powerups.push({\n            x: tx,\n            y: ty,\n            type,\n            duration: conf.COUNTDOWN\n          });\n        }\n      } // Afin de vérifier si une autre bombe est dans l'intervalle de l'explosion de cette bombe\n      // Si oui, on l'explose aussi IMMEDIATEMENT\n\n\n      const chain = state.bombs.find(b => b.x === tx && b.y === ty);\n\n      if (chain) {\n        explodeBomb(chain, state);\n      }\n\n      state.explosions.push({\n        x: tx,\n        y: ty,\n        duration: conf.EXPLOSIONDURATION\n      });\n    }\n  };\n\n  affectTiles(x, y);\n  const directions = [{\n    dx: 0,\n    dy: -1\n  }, // up\n  {\n    dx: 0,\n    dy: 1\n  }, // down\n  {\n    dx: -1,\n    dy: 0\n  }, // left\n  {\n    dx: 1,\n    dy: 0\n  } // right\n  ];\n\n  for (const dir of directions) {\n    for (let i = 1; i <= range; i++) {\n      const tx = x + dir.dx * i;\n      const ty = y + dir.dy * i;\n      if (tx < 0 || tx >= state.gameMap.width || ty < 0 || ty >= state.gameMap.height) break;\n      const tile = state.gameMap.tiles[ty][tx];\n      if (tile === TileType.WALL || tile === TileType.WATER) break; // On ne peut pas casser les murs ni brûler l'eau\n\n      affectTiles(tx, ty); // Si le joueur ou un ennemi est touché par l'explosion\n\n      if (state.player.alive && (state.player.x === x && state.player.y === y || state.player.x === tx && state.player.y === ty)) {\n        state.player.alive = false;\n        state.gameOver = true;\n      } // Si un ennemi est touché par l'explosion\n\n\n      state.enemies.forEach(enemy => {\n        if (enemy.alive && enemy.x === tx && enemy.y === ty) {\n          enemy.alive = false;\n          state.score += conf.ENEMYSCORE; // Score pour les ennemis\n\n          state.floatingTexts.push({\n            // Texte flottant pour le score des ennemis\n            x: enemy.x * conf.TILESIZE,\n            y: enemy.y * conf.TILESIZE,\n            value: `+${conf.ENEMYSCORE}`,\n            duration: conf.FLOATTEXTDURATION\n          });\n        }\n      });\n      if (tile === TileType.BREAKABLE) break; // On casse la brique et on arrête l'explosion\n    }\n  } // state.player.bombs++\n\n}; // Fonction pour générer un état initial du jeu\n\nexport const createInitialState = () => ({\n  player: {\n    x: conf.XPLAYER,\n    y: conf.YPLAYER,\n    alive: true,\n    bombs: conf.BOMBS,\n    bombRange: conf.BOMBRANGE,\n    direction: 'right'\n  },\n  bombs: [],\n  explosions: [],\n  enemies: [],\n  gameMap: {\n    width: conf.WIDTH,\n    height: conf.HEIGHT,\n    tiles: generateMap(conf.WIDTH, conf.HEIGHT)\n  },\n  gameOver: false,\n  victory: false,\n  powerups: [],\n  gameStarted: false,\n  level: conf.STARTINGLEVEL,\n  maxLevel: conf.MAXLEVEL,\n  levelTimer: conf.LEVELTIME,\n  score: 0,\n  paused: false,\n  muted: false,\n  zoom: 1.0,\n  floatingTexts: []\n});","map":{"version":3,"sources":["/home/munou/stl/year_2/2/cpa/projet_de_0/CPA-Bomber_Man/src/components/canvas/state.ts"],"names":["conf","TileType","generateMap","width","height","map","y","row","x","push","WALL","random","Math","BREAKABLEPROBABILITY","BREAKABLE","WATERPROBABILITYAUX","WATER","EMPTY","isWalkable","tile","explodeBomb","bomb","state","range","bombs","filter","b","owner","player","affectTiles","tx","ty","gameMap","tiles","score","BREAKABLESCORE","floatingTexts","TILESIZE","value","duration","FLOATTEXTDURATION","POWERUPROBABILITY","types","type","floor","length","powerups","COUNTDOWN","chain","find","explosions","EXPLOSIONDURATION","directions","dx","dy","dir","i","alive","gameOver","enemies","forEach","enemy","ENEMYSCORE","createInitialState","XPLAYER","YPLAYER","BOMBS","bombRange","BOMBRANGE","direction","WIDTH","HEIGHT","victory","gameStarted","level","STARTINGLEVEL","maxLevel","MAXLEVEL","levelTimer","LEVELTIME","paused","muted","zoom"],"mappings":"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","sourcesContent":["// Sorbonne Université\n// M1 STL 2024/2025\n// Conception et Pratique de l’Algorithmique\n// Projet final: Refonte d'une application de jeu vidéo\n// ALABDULLAH Muhannad\n// 21317509\n\n// Ce fichier contient les structures des différents éléments du jeu\n//\n// Il contient également des fonctions pour générer la carte, et l'état initial du jeu\n//\n// et pour gérer les explosions des bombes\n\nimport * as conf from './conf'\n\nexport enum TileType {\n\tEMPTY,\n\tWALL,\n\tBREAKABLE,\n\tEXPLOSION,\n\tWATER\n}\n\nexport type Player = {\n\tx : number\n\ty : number\n\talive : boolean\n\tbombs : number\n\tbombRange : number\n\tdirection : 'up' | 'down' | 'left' | 'right'\n}\n\nexport type Bomb = {\n\tx : number\n\ty : number\n\trange : number\n\ttimer : number\n\towner : 'player' | 'enemy' // bombes des ennemis pas implémentées\n}\n\nexport type Explosion = {\n\tx : number\n\ty : number\n\tduration : number\n}\n\nexport type Enemy = {\n\tx : number\n\ty : number\n\talive : boolean\n\tdirection : 'up' | 'down' | 'left' | 'right'\n\tmoveEvery : number // Vitesse de l'ennemi, elevée = plus lent\n\taiType?: 'smart' | 'random'\n}\n\nexport type GameMap = {\n\twidth: number\n\theight: number\n\ttiles: TileType[][]\n}\n\nexport type PowerUpType = 'bomb' | 'range' | 'freeze'\n\nexport type PowerUp = {\n\tx : number\n\ty : number\n\ttype : PowerUpType\n\tduration? : number\n}\n\nexport type FloatingText = {\n\tx: number\n\ty: number\n\tvalue: string\n\tduration: number\n}\n\nexport type State = {\n\tplayer: Player\n\tbombs: Bomb[]\n\texplosions: Explosion[]\n\tenemies: Enemy[]\n\tgameMap: GameMap\n\tgameOver: boolean\n\tvictory: boolean\n\tpowerups: PowerUp[]\n\tfreezeTimer?: number\n\tgameStarted : boolean\n\tlevel: number\n\tmaxLevel: number\n\tlevelTimer: number\n\tscore: number\n\tpaused: boolean\n\tmuted: boolean\n\tzoom: number\n\tfloatingTexts: FloatingText[]\n}\n\nexport const generateMap = (width: number, height: number): TileType[][] => {\n\tconst map: TileType[][] = []\n\n\tfor (let y = 0; y < height; y++) {\n\t\tconst row: TileType[] = []\n\t\tfor (let x = 0; x < width; x++) {\n\t\t\tif (x === 0 || x === width - 1 || y === 0 || y === height - 1) {\n\t\t\t\trow.push(TileType.WALL)\n\t\t\t}\n\t\t\telse if (x % 2 === 0 && y % 2 === 0) {\n\t\t\t\trow.push(TileType.WALL)\n\t\t\t}\n\t\t\telse{\n\t\t\t\tconst random = Math.random()\n\t\t\t\tif (random < conf.BREAKABLEPROBABILITY) {\n\t\t\t\t\trow.push(TileType.BREAKABLE)\n\t\t\t\t} else if (random < conf.WATERPROBABILITYAUX) {\n\t\t\t\t\trow.push(TileType.WATER)\n\t\t\t\t} else {\n\t\t\t\t\trow.push(TileType.EMPTY)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap.push(row)\n\t}\n\n\t// Afin de rassurer que les case de départ sont vides\n\tmap[1][1] = TileType.EMPTY\n\tmap[1][2] = TileType.EMPTY\n\tmap[2][1] = TileType.EMPTY\n\n\treturn map\n}\n\nexport const isWalkable = (tile: TileType): boolean => {\n\treturn tile === TileType.EMPTY || tile === TileType.WATER\n}\n\nexport const explodeBomb = (bomb: Bomb, state: State) => {\n\tconst {x, y, range} = bomb\n\n\tstate.bombs = state.bombs.filter(b => b !== bomb)\n\tif (bomb.owner === 'player') {\n\t\tstate.player.bombs++\n\t}\n\tconst affectTiles = (tx: number, ty: number) => {\n\t\tif (tx >= 0 && tx < state.gameMap.width && ty >= 0 && ty < state.gameMap.height) {\n\t\t\tconst tile = state.gameMap.tiles[ty][tx]\n\t\t\tif (tile === TileType.BREAKABLE) { // Casser les briques\n\t\t\t\tstate.gameMap.tiles[ty][tx] = TileType.EMPTY\n\t\t\t\tstate.score += conf.BREAKABLESCORE // Score pour les briques\n\t\t\t\tstate.floatingTexts.push({ // Texte flottant pour le score des briques\n\t\t\t\t\tx: tx * conf.TILESIZE,\n\t\t\t\t\ty: ty * conf.TILESIZE,\n\t\t\t\t\tvalue: `+${conf.BREAKABLESCORE}`,\n\t\t\t\t\tduration: conf.FLOATTEXTDURATION\n\t\t\t\t})\n\t\t\t\tif (Math.random() < conf.POWERUPROBABILITY) { // Chance de faire apparaître un powerup\n\t\t\t\t\tconst types: PowerUpType[] = ['bomb', 'range', 'freeze']\n\t\t\t\t\tconst type = types[Math.floor(Math.random() * types.length)]\n\n\t\t\t\t\tstate.powerups.push({ x: tx, y: ty, type, duration: conf.COUNTDOWN })\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Afin de vérifier si une autre bombe est dans l'intervalle de l'explosion de cette bombe\n\t\t\t// Si oui, on l'explose aussi IMMEDIATEMENT\n\t\t\tconst chain = state.bombs.find(b => b.x === tx && b.y === ty)\n\t\t\tif(chain) {\n\t\t\t\texplodeBomb(chain,state)\n\t\t\t}\n\t\t\tstate.explosions.push({ x: tx, y: ty, duration: conf.EXPLOSIONDURATION })\n\t\t}\n\t}\n\n\taffectTiles(x, y)\n\tconst directions = [\n\t\t{ dx: 0, dy: -1 }, // up\n\t\t{ dx: 0, dy: 1 }, // down\n\t\t{ dx: -1, dy: 0 }, // left\n\t\t{ dx: 1, dy: 0 } // right\n\t]\n\n\tfor (const dir of directions) {\n\t\tfor (let i = 1; i <= range; i++) {\n\t\t\tconst tx = x + dir.dx * i\n\t\t\tconst ty = y + dir.dy * i\n\t\t\tif (tx < 0 || tx >= state.gameMap.width || ty < 0 || ty >= state.gameMap.height) break\n\t\t\t\n\t\t\tconst tile = state.gameMap.tiles[ty][tx]\n\t\t\tif (tile === TileType.WALL || tile === TileType.WATER) break // On ne peut pas casser les murs ni brûler l'eau\n\t\t\taffectTiles(tx, ty)\n\t\t\t\n\t\t\t// Si le joueur ou un ennemi est touché par l'explosion\n\t\t\tif (state.player.alive && ((state.player.x === x && state.player.y === y) || (state.player.x === tx && state.player.y === ty))) {\n\t\t\t\tstate.player.alive = false\n\t\t\t\tstate.gameOver = true\n\t\t\t}\n\t\t\t// Si un ennemi est touché par l'explosion\n\t\t\tstate.enemies.forEach(enemy => {\n\t\t\t\tif (enemy.alive && enemy.x === tx && enemy.y === ty) {\n\t\t\t\t\tenemy.alive = false\n\t\t\t\t\tstate.score += conf.ENEMYSCORE // Score pour les ennemis\n\t\t\t\t\tstate.floatingTexts.push({ // Texte flottant pour le score des ennemis\n\t\t\t\t\t\tx: enemy.x * conf.TILESIZE,\n\t\t\t\t\t\ty: enemy.y * conf.TILESIZE,\n\t\t\t\t\t\tvalue: `+${conf.ENEMYSCORE}`,\n\t\t\t\t\t\tduration: conf.FLOATTEXTDURATION\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t\tif (tile === TileType.BREAKABLE) break // On casse la brique et on arrête l'explosion\n\t\t}\n\t}\n\t// state.player.bombs++\n}\n\n// Fonction pour générer un état initial du jeu\nexport const createInitialState = ():State => (\n\t{\n\t\tplayer: {\n\t\t\tx: conf.XPLAYER,\n\t\t\ty: conf.YPLAYER,\n\t\t\talive: true,\n\t\t\tbombs: conf.BOMBS,\n\t\t\tbombRange: conf.BOMBRANGE,\n\t\t\tdirection: 'right',\n\t\t},\n\t\tbombs: [],\n\t\texplosions: [],\n\t\tenemies: [],\n\t\tgameMap: {\n\t\t\twidth: conf.WIDTH,\n\t\t\theight: conf.HEIGHT,\n\t\t\ttiles: generateMap(conf.WIDTH, conf.HEIGHT),\n\t\t},\n\t\tgameOver: false,\n\t\tvictory: false,\n\t\tpowerups: [],\n\t\tgameStarted: false,\n\t\tlevel: conf.STARTINGLEVEL,\n\t\tmaxLevel: conf.MAXLEVEL,\n\t\tlevelTimer: conf.LEVELTIME,\n\t\tscore: 0,\n\t\tpaused: false,\n\t\tmuted: false,\n\t\tzoom: 1.0,\n\t\tfloatingTexts: [],\n\t}\n)"]},"metadata":{},"sourceType":"module","externalDependencies":[]}